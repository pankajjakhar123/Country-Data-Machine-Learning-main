# -*- coding: utf-8 -*-
"""minor_project(05).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wd1TojK2CJ1na6AZAxd2q55fVXF2jxPV

#Minor Project

##Reading the dataset
"""

import pandas as pd
import numpy as np
dataset=pd.read_csv("Country-data (1).csv")
dataset1=dataset
dataset.head(20)

dataset.describe()

#Converting health ,imoprt ,export into value of contribution in GDB
dataset['exports']=(dataset['exports']*dataset['gdpp'])/100
dataset['imports']=(dataset['imports']*dataset['gdpp'])/100
dataset['health']=(dataset['health']*dataset['gdpp'])/100

shape=dataset.shape
print(shape)

"""Our dataset has 167 rows and 10 column

##Visualisation dataset
"""

dataset.info()
# checking for missing values
dataset.isnull().sum()

"""Sice all the column has 167 non NULL value so we don't have null value in dataset"""

#Droping the country column
dataset=dataset.drop(['country'],axis=1)
dataset

#visulizating the dataset
from matplotlib import pyplot as plt
col=['child_mort','exports','health','imports','income','inflation','life_expec','total_fer','gdpp']

#Plotting the histogram of the dataset
dataset.hist(bins=20,figsize=(12,12))

#Plotting the scatter between each pair
import seaborn as sns
sns.pairplot(dataset)

import plotly.graph_objs as go
#Plotting the 3d scatter plot between child mort , health ,income
x = dataset['child_mort']
y = dataset['health']
z = dataset['income']
fig = go.Figure(data=[go.Scatter3d(x=x, y=y, z=z, mode='markers')])

fig.update_layout(
    title='3D Scatter Plot',
    scene=dict(
        xaxis_title='child_mort',
        yaxis_title='health',
        zaxis_title='income'
    )
)
fig.show()

import plotly.graph_objs as go
#Plotting the 3d scatter plot between life_expec,inflation ,exports
x = dataset['life_expec']
y = dataset['inflation']
z = dataset['exports']
fig = go.Figure(data=[go.Scatter3d(x=x, y=y, z=z)])

fig.update_layout(
    title='3D Scatter Plot',
    scene=dict(
        xaxis_title='life_expec',
        yaxis_title='inflation',
        zaxis_title='exports'
    )
)
fig.show()

#Plotting all the country of the dataset on the world map
import plotly.express as px
import pandas as pd
df = pd.DataFrame({
    'Country': dataset1['country'],
})
fig = px.choropleth(df,
                    locations='Country',
                    locationmode='country names',
                    hover_name='Country',
                    color_continuous_scale=px.colors.sequential.Plasma,
                    projection='natural earth')
fig.update_layout(title_text='World Map')
fig.show()

import matplotlib.pyplot as plt
import seaborn as sns
plt.figure(figsize=(12,10))

corr_pca=np.corrcoef(dataset.transpose())
corr_matrix =dataset.corr()
plt.figure(figsize=(10, 8))
sns.clustermap(corr_matrix, annot=True, figsize=(10, 10))
plt.title("correlation of the variables - countries")
plt.show()

"""The heatmap shows that some variables have high correlations with positive and negative responses, which need to be removed. PCA will be used to overcome this multicollinearity, preserving valuable information and reducing dimensionality. This will take care of multicollinearity while also preserving valuable information and reducing dimensionality."""

#Scaling the dataset
#Using standard scalar
from sklearn.preprocessing import StandardScaler
scaler=StandardScaler()
data_scal=scaler.fit_transform(dataset)
data_scal=pd.DataFrame(data_scal,columns=col)
data_scal.head()

"""##Dimensionality reduction - PCA"""

#Using PCA
from sklearn.decomposition import PCA
pca = PCA(svd_solver='randomized', random_state=42)
pca.fit(data_scal)
pc_cols = ['PC1', 'PC2']
#DataFrame of pca_df
pca_df=pd.DataFrame({pc_cols[0]: pca.components_[0],pc_cols[1]:pca.components_[1], 'feature':col})
pca_df.head()



fig=plt.figure(figsize=(10,10))
#Plotting the scatter plot with the point name as feature
plt.scatter(pca_df.PC1,pca_df.PC2,label=pca_df["feature"],color='red')
plt.title('PC 1 vs PC 2')
plt.xlabel('PC 1')
plt.ylabel('PC 2')
c=0
for (a, b) in zip(pca_df['PC1'], pca_df['PC2']):
    plt.text(a, b, pca_df['feature'][c],fontsize=10)
    c+=1
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
# Create a scree plot
sns.set_style("whitegrid")
plt.figure(figsize=(8, 6))
plt.plot(np.cumsum(pca.explained_variance_ratio_),color='red')
plt.title('Scree Plot')
plt.xlabel('Number of components')
plt.ylabel('Cumulative Variance')
plt.xticks(range(0, len(pca.explained_variance_ratio_), 5))
plt.show()

import warnings
warnings.filterwarnings('ignore')
plt.figure(figsize=(50,150))
plt.tight_layout()
sns.set_style()
sns.set_context('talk')
#Defining the dictionary for column names
col={0:'Child_Mortality',1:'Exports',2:'Health',3:'Imports',4:'Income',5:'Inflation',
     6:'Life_expectancy',7:'Total_number_of_children_per_Woman',8:'GDPP'}
# Visualising the outliers with boxplot for all the variables
for i in range(9):
    plt.subplot(9,3,i+1)
    plt.title(col[i],fontsize=50)
    sns.boxplot(x=data_scal.columns[i-1],data=data_scal,orient='v',fliersize=15)

# Visualize the outliers with a violin plot for all the variables
#Checking the spread to get outliers
sns.set_style()
sns.set_context('talk')
plt.figure(figsize=(50,150))
plt.tight_layout()

for i in range(9):
    plt.subplot(9, 3, i+1)
    plt.title(col[i], fontsize=50)
    sns.violinplot(x=data_scal.columns[i-1], data=data_scal, orient='v', scale='count')
    plt.xlabel('')
    plt.ylabel('')
    plt.tick_params(axis='both', which='major', labelsize=40)

plt.show()

from sklearn.decomposition import IncrementalPCA
#Using increment PCA
pca_final=IncrementalPCA(n_components=5)
pca_scaled_df=pca_final.fit_transform(data_scal)
pca_scaled_df1=pd.DataFrame(pca_scaled_df)
pca_scaled_df1.head()



#Correlation matrix of the reduced dataset
corr_pca=np.corrcoef(pca_scaled_df1.transpose())
corr_matrix = pca_scaled_df1.corr()
plt.figure(figsize=(10, 8))
sns.clustermap(corr_matrix, annot=True, figsize=(10, 10))
plt.title("Correlation of the variables after PCA - countries")
plt.show()

# corr_matrix.to_numpy
np.fill_diagonal(corr_matrix.values, np.nan)
max_corr = corr_matrix.max().max()
min_corr = corr_matrix.min().min()
# printing the min-max values
print("maximum correlation:",max_corr, ", minimum correlation: ", min_corr)

#new dataset after pca of original dataset
new_dataset=pd.DataFrame(pca_scaled_df)
col1={0:'PC1',1:'PC2',2:'PC3',3:'PC4',4:'PC5',5:'PC6'}
new_dataset=new_dataset.rename(columns=col1)
new_dataset.head()

"""##K Means"""



from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

clusters_range=[2,3,4,5,6,7,8]
for i in clusters_range:
    kmeans=KMeans(n_clusters=i, max_iter=500, n_init=10, random_state=42)
    kmeans.fit(new_dataset)
    cluster_label=kmeans.labels_
    S_score=silhouette_score(new_dataset,cluster_label)
    print("Cluster={0} has silhouette score {1}".format(i,S_score))

#Taking n=4 and max iter=500
kmeans=KMeans(n_clusters=4,max_iter=500,n_init=10,random_state=42)
kmeans.fit(new_dataset)

kmeans.labels_

dataset1['Cluster_id']=kmeans.labels_
dataset1.head()

plt.figure(figsize=(10,10))
plt.tight_layout()



plt.title('Cluster_id', fontsize=50)
sns.violinplot(x=dataset1['Cluster_id'], data=dataset1, orient='v', scale='count')
plt.xlabel('')
plt.ylabel('')
plt.tick_params(axis='both', which='major', labelsize=40)

plt.show()

#Plotting figure for life expantancy
plt.figure()
plt.title('Cluster level vs Life expec')
sns.boxplot(x='Cluster_id',y='life_expec',data=dataset1)

# Visualize the outliers with a violin plot for all the variables
#Checking the spread to get outliers
sns.set_style()
sns.set_context('talk')

#Plottig figure for income
plt.figure()
plt.title('Cluster level vs Income')
sns.boxplot(x='Cluster_id',y='income',data=dataset1)

#Plotting for gdpp
plt.figure()
plt.title('Cluster level vs gdpp')
sns.boxplot(x='Cluster_id',y='gdpp',data=dataset1)

#Plotting for child mortality
plt.figure()
plt.title('Cluster level vs Child Mortality')
sns.boxplot(x='Cluster_id',y='child_mort',data=dataset1)

new_dataset['Cluster_label']=kmeans.labels_
new_dataset.set_index(dataset.index,inplace=True)
new_dataset.head()

fig = plt.figure(figsize=(14,10))

plt.scatter(new_dataset.iloc[:,0], new_dataset.iloc[:,1],
            c = new_dataset.Cluster_label.map({0:'green',1:'red',2:'orange',3:'blue'}))
plt.title("PC 1 vs PC2")
p=0
for i, txt in enumerate(new_dataset.index):
    plt.annotate(dataset1.iloc[p,0], (new_dataset.PC1[i],new_dataset.PC2[i]),fontsize=6)
    p+=1
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.tight_layout()
plt.show()

fig = plt.figure(figsize=(14,10))
dataset1['Cluster_id']=kmeans.labels_
dataset1.head()
plt.scatter(dataset1['child_mort'], dataset1['gdpp'],
            c = dataset1.Cluster_id.map({0:'orange',1:'red',2:'blue',3:'green'}))

p=0
for i, txt in enumerate(dataset1.index):
    plt.annotate(dataset1.iloc[p,0], (dataset1.child_mort[i],dataset1.gdpp[i]),fontsize=6)
    p+=1
plt.title('Child_Mortality vs GDPP per capita')
plt.xlabel('Child_Mortality')
plt.ylabel('GDP per capita')
plt.tight_layout()
plt.show()

sns.set_style("whitegrid")
plt.figure(figsize=(12,8))
sns.scatterplot(data=dataset1, x='child_mort', y='gdpp', hue='Cluster_id', palette='deep')
plt.title('Child_Mortality vs GDPP per capita')
plt.xlabel('Child_Mortality')
plt.ylabel('GDP per capita')
plt.show()

import plotly.express as px
import pandas as pd
df = pd.DataFrame({
    'Country': dataset1['country'],
    'Value': new_dataset.Cluster_label
})

fig = px.choropleth(df,
                    locations='Country',
                    locationmode='country names',
                    color='Value',
                    hover_name='Country',
                    color_continuous_scale=px.colors.sequential.Plasma,
                    projection='natural earth')

fig.update_layout(title_text='World Map')
fig.show()

#Plotting the bar graph to show the disribution of number of country in each cluster
cluster_counts = new_dataset['Cluster_label'].value_counts()
plt.figure(figsize=(8, 6))
plt.bar(cluster_counts.index, cluster_counts.values,color='black')
plt.xlabel('Cluster label')
plt.ylabel('Number of countries')
plt.title('Distribution of countries across clusters')

plt.show()

#Cluster witrh label=0
nohelp=pd.DataFrame(new_dataset[new_dataset['Cluster_label']==0].index)
print(nohelp.shape)

#Cluster witrh label=1
help=pd.DataFrame(new_dataset[new_dataset['Cluster_label']==1].index)
print(help.shape)

#Cluster witrh label=2
Country1=pd.DataFrame(new_dataset[new_dataset['Cluster_label']==2].index)
print(Country1.shape)

#Cluster witrh label=3
Country2=pd.DataFrame(new_dataset[new_dataset['Cluster_label']==3].index)
print(Country2.shape)

"""##Hierarchical Clustering"""



#using hierarchical clustring
hier_cluster = new_dataset.drop(columns='Cluster_label')
hier_cluster.head()
from scipy.cluster.hierarchy import linkage
from scipy.cluster.hierarchy import dendrogram
from scipy.cluster.hierarchy import cut_tree



import plotly.figure_factory as ff

fig = ff.create_dendrogram(hier_cluster.values, labels=hier_cluster.index)
fig.update_layout(width=800, height=500, title="Dendrogram - Single linkage")
fig.show()

complete_linkage=linkage(hier_cluster,method='complete',metric='euclidean')
from scipy.cluster.hierarchy import linkage, dendrogram
import matplotlib.pyplot as plt

plt.figure(figsize=(15, 10))
plt.title('Dendrogram - Complete Linkage')
plt.xlabel('Country', fontsize=20)
plt.ylabel('PC_value', fontsize=20)

linkage_matrix = linkage(hier_cluster, method='complete', metric='euclidean')
dendrogram(linkage_matrix, above_threshold_color='blue', color_threshold=5.5, labels=hier_cluster.index)

plt.show()

#Clusterlabel
cluster_label=cut_tree(complete_linkage,n_clusters=3).reshape(-1, )
cluster_label

hier_cluster['Cluster_label']=cluster_label
hier_cluster.head()

fig = plt.figure(figsize = (10,8))
plt.title("PC 1 vs PC 2")
plt.scatter(hier_cluster.iloc[:,0], hier_cluster.iloc[:,1],
            c = hier_cluster.Cluster_label.map({0:'red',1:'blue',2:'green',3:'orange'}))
p=0
for i, txt in enumerate(hier_cluster.index):
    plt.annotate(dataset1.iloc[p,0], (hier_cluster.PC1[i],hier_cluster.PC2[i]),fontsize=6)
    p+=1
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.tight_layout()
plt.show()

plt.figure(figsize=(12,8))
sns.set_style('whitegrid')
sns.set_context('talk')
plt.title('Cluster Visualization')

# scatter plot for PC1 and PC2
plt.scatter(hier_cluster.iloc[:,0], hier_cluster.iloc[:,1],
            c = hier_cluster.Cluster_label.map({0:'red',1:'blue',2:'green',3:'orange'}),
            alpha=0.8, s=100)

# plot cluster centers
centers = np.array(kmeans.cluster_centers_)
plt.scatter(centers[:,0], centers[:,1], c='black', s=200, marker='X')

plt.xlabel('PC1')
plt.ylabel('PC2')
plt.tight_layout()
plt.show()

cntry_df_hier=dataset1.drop('Cluster_id',1)    # creating separate dataset for hierarchical cluster analysis
cntry_df_hier['Cluster_level']=cluster_label
cntry_df_hier.head()

plt.figure(figsize=(10,20))
plt.tight_layout()
sns.set_style('whitegrid')
sns.set_context('talk')
plt.subplot(4,1,1)
plt.title('life_expec',fontsize=25)
sns.boxplot(x=cntry_df_hier['Cluster_level'],y=cntry_df_hier['life_expec'],data=cntry_df_hier,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,2)
plt.title('Child_Mortality',fontsize=25)
sns.boxplot(x=cntry_df_hier['Cluster_level'],y=cntry_df_hier['child_mort'],data=cntry_df_hier,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,3)
plt.title('Income',fontsize=25)
sns.boxplot(x=cntry_df_hier['Cluster_level'],y=cntry_df_hier['income'],data=cntry_df_hier,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,4)
plt.title('GDPP per capita',fontsize=25)
sns.boxplot(x=cntry_df_hier['Cluster_level'],y=cntry_df_hier['gdpp'],data=cntry_df_hier,palette='gist_heat',orient='v',fliersize=5)
plt.tight_layout()

"""##Insight(Hierarchical Approach 1)"""

Country_help_hier=pd.DataFrame(hier_cluster[hier_cluster['Cluster_label']==0].index)
Country_help_hier.shape

"""##Approach 2: Exclude outliers"""

new_scaled_df=data_scal
col=['child_mort','exports','health','imports','income','inflation','life_expec','total_fer','gdpp']
for i in range(len(col)):
    lower=new_scaled_df[col[i]].quantile(0.05)
    upper=new_scaled_df[col[i]].quantile(0.95)
    IQR=upper-lower
    new_scaled_df=new_scaled_df[(new_scaled_df[col[i]] >=lower - 1.5*IQR) & (new_scaled_df[col[i]] <=upper + 1.5*IQR)]

from sklearn.decomposition import IncrementalPCA
pca_final1=IncrementalPCA(n_components=5)
new_pca_scaled=pca_final1.fit_transform(new_scaled_df)
new_pca_scaled.shape

corr_pca1=np.corrcoef(new_pca_scaled.transpose())
plt.figure(figsize=(10, 8))
sns.clustermap(corr_pca1, annot=True, figsize=(10, 10))
plt.title("correlation of the variables - countries")
plt.show()

corr_pca_minmax = corr_pca1 - np.diagflat(corr_pca1.diagonal())
print("maximum correlation:",corr_pca_minmax.max(), ", minimum correlation: ", corr_pca_minmax.min(),)

new_scaled_data=pd.DataFrame(new_pca_scaled)
col1={0:'PC1',1:'PC2',2:'PC3',3:'PC4',4:'PC5',5:'PC6'}
new_scaled_data=new_scaled_data.rename(columns=col1)
new_scaled_data.head()

"""##Silhouette Analysis"""

#Using silhouette analysis
cntry_df=data_scal.reset_index()
new_cntry_df=dataset1.iloc[new_scaled_df.index].copy()
new_cntry_df=new_cntry_df.drop(columns=['Cluster_id'])

import sklearn
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

clusters_range=[2,3,4,5,6,7,8,9]
for i in clusters_range:
    kmeans_new=KMeans(n_clusters=i,max_iter=500, n_init=10)
    kmeans_new.fit(new_scaled_data)
    cluster_labels=kmeans_new.labels_
    silhouette_Score=silhouette_score(new_scaled_data,cluster_labels)
    print("Cluster={0} has silhouette score {1}".format(i,silhouette_Score))

kmeans_2=KMeans(n_clusters=3,max_iter=500,random_state=42,n_init=10)
kmeans_2.fit(new_scaled_data)

kmeans_2.labels_

new_cntry_df['Cluster_id']=kmeans_2.labels_
new_cntry_df.head()

"""##Visualization with PCS1 and PCS2"""

new_scaled_data['Cluster_label']=kmeans_2.labels_
new_scaled_data.set_index(new_cntry_df.country,inplace=True)
new_scaled_data.head()

fig = plt.figure(figsize = (14,10))
plt.title("PC 1 vs PC 2")
plt.scatter(new_scaled_data.iloc[:,0], new_scaled_data.iloc[:,1],
            c = new_scaled_data.Cluster_label.map({0:'blue',1:'green',2:'red'}))
for i, txt in enumerate(new_scaled_data.index):
    plt.annotate(txt, (new_scaled_data.PC1[i],new_scaled_data.PC2[i]),fontsize=6)
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.tight_layout()
plt.show()

import plotly.express as px
import pandas as pd
df = pd.DataFrame({
    'Country': dataset1['country'],
    'Value': new_cntry_df['Cluster_id']
})

# use Plotly Express to create a world map
fig = px.choropleth(df,
                    locations='Country',
                    locationmode='country names',
                    color='Value',
                    hover_name='Country',
                    color_continuous_scale=px.colors.sequential.Plasma,
                    projection='natural earth')
fig.update_layout(title_text='World Map')
fig.show()

"""##Visualisation of original variables(gdpp, income and child_mort)"""

#Plotting the bar graph to show the disribution of number of country in each cluster
cluster_counts = new_scaled_data['Cluster_label'].value_counts()
plt.figure(figsize=(8, 6))
plt.bar(cluster_counts.index, cluster_counts.values,color='black')
plt.xlabel('Cluster label')
plt.ylabel('Number of countries')
plt.title('Distribution of countries across clusters')

plt.show()

#Usin the boxplot for showing out liers
plt.figure(figsize=(10,20))
plt.tight_layout()
sns.set_style('whitegrid')
sns.set_context('talk')
plt.subplot(4,1,1)
plt.title('life_expec',fontsize=25)
sns.boxplot(x=new_cntry_df['Cluster_id'],y=new_cntry_df['life_expec'],data=new_cntry_df,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,2)
plt.title('Child_Mortality',fontsize=25)
sns.boxplot(x=new_cntry_df['Cluster_id'],y=new_cntry_df['child_mort'],data=new_cntry_df,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,3)
plt.title('Income',fontsize=25)
sns.boxplot(x=new_cntry_df['Cluster_id'],y=new_cntry_df['income'],data=new_cntry_df,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,4)
plt.title('GDPP per capita',fontsize=25)
sns.boxplot(x=new_cntry_df['Cluster_id'],y=new_cntry_df['gdpp'],data=new_cntry_df,palette='gist_heat',orient='v',fliersize=5)
plt.tight_layout()

"""##Insights (K-Means Approach 2)"""

Country_help1=pd.DataFrame(new_scaled_data[new_scaled_data['Cluster_label']==2].index)
Country_help1.shape

Country_nohelp1=pd.DataFrame(new_scaled_data[new_scaled_data['Cluster_label']==1].index)
Country_nohelp1.shape

hier_cluster1=new_scaled_data.drop(columns='Cluster_label')
hier_cluster1.head()



import plotly.figure_factory as ff
#Using dendigram plot
fig = ff.create_dendrogram(hier_cluster1.values, labels=hier_cluster1.index)
fig.update_layout(width=1500, height=800, title="Dendrogram - Single linkage")
fig.show()

complete_linkage1=linkage(hier_cluster1,method='complete',metric='euclidean')
from scipy.cluster.hierarchy import linkage, dendrogram
import matplotlib.pyplot as plt

plt.figure(figsize=(15, 10))
plt.title('Dendrogram - Complete Linkage')
plt.xlabel('Country', fontsize=20)
plt.ylabel('PC_value', fontsize=20)

linkage_matrix = linkage(hier_cluster1, method='complete', metric='euclidean')
dendrogram(linkage_matrix, above_threshold_color='blue', color_threshold=5.5, labels=hier_cluster1.index)

plt.show()

cluster_label1=cut_tree(complete_linkage1,n_clusters=3).reshape(-1, )
cluster_label1

hier_cluster1['Cluster_label']=cluster_label1
hier_cluster1.head()

cntry_df_hier1=new_cntry_df.drop('Cluster_id',1)
cntry_df_hier1['Cluster_level']=cluster_label1
cntry_df_hier1.head()

plt.figure(figsize=(10,20))
plt.tight_layout()
sns.set_style('whitegrid')
sns.set_context('talk')

plt.subplot(4,1,1)
plt.title('life_expec',fontsize=25)
sns.boxplot(x=cntry_df_hier1['Cluster_level'],y=cntry_df_hier1['life_expec'],data=cntry_df_hier1,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,2)
plt.title('Child_Mortality',fontsize=25)

sns.boxplot(x=cntry_df_hier1['Cluster_level'],y=cntry_df_hier1['child_mort'],data=cntry_df_hier1,palette='gist_heat',orient='v',fliersize=5)
plt.subplot(4,1,3)
plt.title('GDPP per capita',fontsize=25)
sns.boxplot(x=cntry_df_hier1['Cluster_level'],y=cntry_df_hier1['gdpp'],data=cntry_df_hier1,palette='gist_heat',orient='v',fliersize=5)

plt.subplot(4,1,4)
plt.title('Income',fontsize=25)
sns.boxplot(x=cntry_df_hier1['Cluster_level'],y=cntry_df_hier1['income'],data=cntry_df_hier1,palette='gist_heat',orient='v',fliersize=5)
plt.tight_layout()

"""##Visualising the PC1 and PC2 for hierarchical clustering - Approach 2"""

fig = plt.figure(figsize = (14,10))
plt.title("PC 1 vs PC 2")
plt.scatter(hier_cluster1.iloc[:,0], hier_cluster1.iloc[:,1],
            c = hier_cluster1.Cluster_label.map({0:'red',1:'green',2:'blue'}))
for i, txt in enumerate(hier_cluster1.index):
    plt.annotate(txt, (hier_cluster1.PC1[i],hier_cluster1.PC2[i]),fontsize=6)
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.tight_layout()
plt.show()

import plotly.express as px
import pandas as pd
df = pd.DataFrame({
    'Country': dataset1['country'],
    'Value': cntry_df_hier1['Cluster_level']
})
# use Plotly Express to create a world map
fig = px.choropleth(df,
                    locations='Country',
                    locationmode='country names',
                    color='Value',
                    hover_name='Country',
                    color_continuous_scale=px.colors.sequential.Plasma,
                    projection='natural earth')
fig.update_layout(title_text='World Map')
fig.show()

import seaborn as sns

sns.set(style="ticks")

# Plotting a scatterplot matrix with hue based on cluster label
sns.pairplot(data=hier_cluster1, vars=['PC1', 'PC2', 'PC3', 'PC4'], hue='Cluster_label',
             palette=['red', 'green', 'blue'], diag_kind='hist', height=2.5)

plt.show()

"""##Insights - (Hierarchical Approach 2)"""

#Plotting the bar graph to show the disribution of number of country in each cluster
cluster_counts = hier_cluster1['Cluster_label'].value_counts()
plt.figure(figsize=(8, 6))
plt.bar(cluster_counts.index, cluster_counts.values,color='black')
plt.xlabel('Cluster label')
plt.ylabel('Number of countries')
plt.title('Distribution of countries across clusters')

plt.show()

help_hier1=pd.DataFrame(hier_cluster1[hier_cluster1['Cluster_label']==0].index)
print(help_hier1.shape)

nohelp_hier1=pd.DataFrame(hier_cluster1[hier_cluster1['Cluster_label']==2].index)

print(nohelp_hier1.shape)





